require(TDA)
require(rgl)
require(myfs)
#3次元図形をプロット
figurePlot<-function(X){
plot3d(X)
aspect3d("iso")
}
figurePlot(torus.300)
torus.300<-torusUnif(300, 1, 2.5)
figurePlot(torus.300)
source('~/R/square-method/square_func.R', encoding = 'UTF-8')
torus.dist<-distance(torus.300)
View(torus.dist)
torus.vic1<-get.vicinity(torus.dist, 1, 10)
#有る点を中心とした近傍点を色付けてプロット
figurePlot.coloredVic<-function(figure, vics, centr){
vics.line<-line.vics(centr)
plot3d(figure[-vics.line, ])
points3d(figure[vics.line, ], col=3)
}
figurePlot.coloredVic(torus.300, torus.vic1, 1)
#有る点を中心とした近傍点を色付けてプロット
figurePlot.coloredVic<-function(figure, vics, centr){
vics.line<-line.vics(centr, vics)
plot3d(figure[-vics.line, ])
points3d(figure[vics.line, ], col=3)
}
figurePlot.coloredVic(torus.300, torus.vic1, 1)
#有る点を中心とした近傍点を色付けてプロット
figurePlot.coloredVic<-function(figure, vics, centr){
vics.line<-line.vics(centr, vics)
plot3d(figure[-vics.line, ])
aspect3d("iso")
points3d(figure[vics.line, ], col=3)
}
figurePlot.coloredVic(torus.300, torus.vic1, 1)
torus.vic1<-get.vicinity(torus.dist, 1, 20)
figurePlot.coloredVic(torus.300, torus.vic1, 1)
torus.vic1<-get.vicinity(torus.dist, 1, 15)
figurePlot.coloredVic(torus.300, torus.vic1, 1)
torus.vic1.line<-line.vics(1, torus.vic1)
torus.vic1.line
vics.pca<-prcomp(torus.300[torus.vic1.line,])
View(vics.pca)
vics.pca[["x"]]
vics.pca
vics.pca[["rotation"]]
vics.pca[["center"]]
vics.pca
summary(vics.pca)
plot(vics.pca[["x"]][,1], vics.pca[["x"]][,2])
figurePlot.coloredVic(torus.300, torus.vic1, 1)
par(new=T)
grid(3, 3, xlim=c(-1.1, 1.1), ylim=c(-0.6, 0.6))
grid(3, 3)
plot(vics.pca[["x"]][,1], vics.pca[["x"]][,2], tck=1)
vics.pca[["x"]]
range(vics.pca[["x"]][,1])
range(vics.pca[["x"]][,2])
plot(vics.pca[["x"]][,1], vics.pca[["x"]][,2], col=4, pch=16)
plot(vics.pca[["x"]][,1], vics.pca[["x"]][,2], col=3, pch=16)
range(vics.pca[["x"]][,1])[1]-range(vics.pca[["x"]][,1])[2]
abs(range(vics.pca[["x"]][,1])[1]-range(vics.pca[["x"]][,1])[2])
abline(v=-1.0026292)
abline(v=0.8339674)
abline(h=-0.7591696)
abline(h=0.6913128)
1.836597/4
abline(v=-1.0026292+(0.4591493*1))
abline(v=-1.0026292+(0.4591493*2))
abline(v=-1.0026292+(0.4591493*3))
abs(range(vics.pca[["x"]][,2])[1]-range(vics.pca[["x"]][,2])[2])
abline(h=-0.7591696+(1.450482*(1/4)))
abline(h=-0.7591696+(1.450482*(2/4)))
abline(h=-0.7591696+(1.450482*(3/4)))
points(-1.0026292+0.4591493*1+(0.4591493/2), -0.7591696+(1.450482*(1/4))+((1.450482*(1/4))/2), pch=16, col=2)
existence(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
existence(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
existence(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
existence(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
existence(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(3/4))), vics.pca[["x"]])
existence(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696+(1.450482*(1/4)), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
abline(h=-0.7591696+(1.450482*(1/4)), col=2)
abline(h=-0.7591696+(1.450482*(2/4)), col=2)
abline(v=-1.0026292, col=4)
abline(v=-1.0026292+(0.4591493*1), col=4)
existence(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696+(1.450482*(1/4)), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
#start, endで区切られた範囲にデータ点が存在しするかしないかを判定する関数
#存在する場合はT、存在しない場合はFを返す
existCheck<-function(start, end, mapped){
exit.e1<-length((1:length(mapped[,1]))[mapped[,1]>=start[1] & mapped[,1]<end[1]])
if(exit.e1>=1){
exie1.mem<-(1:length(mapped[,1]))[mapped[,1]>=start[1] & mapped[,1]<end[1]]
exit.e2<-length((1:length(mapped[exie1.mem, 2]))[mapped[exie1.mem, 2]>=start[2] & mapped[exie1.mem, 2]<end[2]])
if(exit.e2>=1) return(T)
else return(F)
}
else return(T)
}
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696+(1.450482*(1/4)), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
which(vics.pca[["x"]][,1]>=-1.0026292 & vics.pca[["x"]][,1]<-1.0026292+(0.4591493*1))
which(vics.pca[["x"]][,1]>=-1.0026292 & vics.pca[["x"]][,1]<1.0026292+(0.4591493*1))
vics.pca[["x"]]
1.0026292+(0.4591493*1)
which(vics.pca[["x"]][,1]>=-1.0026292 & vics.pca[["x"]][,1]< -1.0026292+(0.4591493*1))
#start, endで区切られた範囲にデータ点が存在しするかしないかを判定する関数
#存在する場合はT、存在しない場合はFを返す
existCheck<-function(start, end, mapped){
exie1.mem<-which(mapped[,1]>=start[1] & mapped[,1]<end[1])
if(length(exie1.mem)>=1){
exie2.mem<-which(mapped[,2]>=start[2] & mapped[,2]<end[2])
if(length(exie2.mem)>=1) return(T)
else return(F)
}
else return(T)
}
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696+(1.450482*(1/4)), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
#start, endで区切られた範囲にデータ点が存在しするかしないかを判定する関数
#存在する場合はT、存在しない場合はFを返す
existCheck<-function(start, end, mapped){
exie1.mem<-which(mapped[,1]>=start[1] & mapped[,1]<end[1])
if(length(exie1.mem)>=1){
exie2.mem<-which(mapped[exie1.mem, 2]>=start[2] & mapped[exie1.mem ,2]<end[2])
if(length(exie2.mem)>=1) return(T)
else return(F)
}
else return(T)
}
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696+(1.450482*(1/4)), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
#start, endで区切られた範囲にデータ点が存在しするかしないかを判定する関数
#存在する場合はT、存在しない場合はFを返す
existCheck<-function(start, end, mapped){
exie1.mem<-which(mapped[,1]>=start[1] & mapped[,1]<end[1])
if(length(exie1.mem)>=1){
exie2.mem<-which(mapped[exie1.mem, 2]>=start[2] & mapped[exie1.mem ,2]<end[2])
if(length(exie2.mem)>=1) return(T)
else return(F)
}
else return(F)
}
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696+(1.450482*(1/4)), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
#start, endで区切られた範囲にデータ点が存在しするかしないかを判定する関数
#存在する場合はT、存在しない場合はFを返す
existCheck<-function(start, end, mapped){
exie1.mem<-which(mapped[,1]>=start[1] & mapped[,1]<end[1])
debugText(exie1.mem)
if(length(exie1.mem)>=1){
exie2.mem<-which(mapped[exie1.mem, 2]>=start[2] & mapped[exie1.mem ,2]<end[2])
debugText(exie2.mem)
if(length(exie2.mem)>=1) return(T)
else return(F)
}
else return(F)
}
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696+(1.450482*(1/4)), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
vics.pca[["x"]]
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
#start, endで区切られた範囲にデータ点が存在しするかしないかを判定する関数
#存在する場合はT、存在しない場合はFを返す
existCheck<-function(start, end, mapped){
exie1.mem<-which(mapped[,1]>=start[1] & mapped[,1]<end[1])
debugText(exie1.mem, start, end)
if(length(exie1.mem)>=1){
exie2.mem<-which(mapped[exie1.mem, 2]>=start[2] & mapped[exie1.mem ,2]<end[2])
debugText(exie2.mem)
if(length(exie2.mem)>=1) return(T)
else return(F)
}
else return(F)
}
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696, -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
existCheck(c(-1.0026292, -1.0026292+(0.4591493*1)), c(-0.7591696+(1.450482*(1/4)), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
existCheck(c(-1.0026292, -0.7591696), c(-1.0026292+(0.4591493*1), -0.7591696+(1.450482*(1/4))), vics.pca[["x"]])
existCheck(c(-1.0026292, -0.7591696+(1.450482*(1/4))), c(-1.0026292+(0.4591493*1), -0.7591696+(1.450482*(2/4))), vics.pca[["x"]])
points(vics.pca[["x"]][8,1:2], col=4, pch=16)
points(vics.pca[["x"]][8,1:2], col=3, pch=16)
vics.pca[["x"]][8,1:2]
points(vics.pca[["x"]][8,1:2], pch=16)
plot(vics.pca[["x"]][,1], vics.pca[["x"]][,2], col=3, pch=16)
points(vics.pca[["x"]][8,1:2], pch=16)
plot(vics.pca[["x"]][-8,1], vics.pca[["x"]][-8,2], col=3, pch=16)
points(vics.pca[["x"]][8,1:2], pch=16)
points(vics.pca[["x"]][8,1], vics.pca[["x"]][8,2], pch=16)
abline(v=-1.0026292)
abline(v=0.8339674)
abline(h=-0.7591696)
abline(h=-0.7591696+(1.450482*(1/4)))
abline(h=0.6913128)
abline(v=-1.0026292+(0.4591493*1))
abline(v=-1.0026292+(0.4591493*2))
abline(v=-1.0026292+(0.4591493*3))
abline(h=-0.7591696+(1.450482*(2/4)))
abline(h=-0.7591696+(1.450482*(3/4)))
points(vics.pca[["x"]][1,1], vics.pca[["x"]][1,2], pch=16)
torus.vic1
sort(torus.vic1[, "distance"])
#格子状の線を引く
gridLine<-function(x, div){
xlim<-range(x[,1])
ylim<-range(x[,2])
wid<-abs(xlim[2]-xlim[1])/div
hei<-abs(ylim[2]-ylim[1])/div
for (i in 0:div) {
abline(v=xlim[1]+i*wid)
abline(h=ylim[1]+i*hei)
}
}
plot(vics.pca[["x"]][-8,1], vics.pca[["x"]][-8,2], col=3, pch=16)
plot(vics.pca[["x"]][,1], vics.pca[["x"]][,2], col=3, pch=16)
gridLine(vics.pca[["x"]])
gridLine(vics.pca[["x"]], 4)
